## Regex

<!-- .slide: class="element-bkg" -->
<!-- .slide: data-background-image="https://media.giphy.com/media/kAq6HQVQmK5WM/giphy.gif" -->

* Expressions that can be generated by regular languages, or that can be produced by a finite automaton

-###-

## What Does That Mean?

<!-- .slide: class="element-bkg" -->
<!-- .slide: data-background-image="https://media.giphy.com/media/GmdFiZtdJtQty/giphy.gif" -->

* Patterns that you can use to match various parts of strings, allowing matches to be made when the exact values to be matched are uncertain
	* Find where email addresses appear in a string of text
	* Check if a string represents a valid phone number

-###-

## Regex in Javascript

* Find a pattern instance in a string
	* `search()`
	* `match()`
* Replace instances of a pattern with other text
	* `replace()`
* Break up the string using the pattern as a boundary
	* `split()`

-###-

## Defining Regular Expressions in Javascript

```javascript
new RegExp(pattern[, flags]);

var re = new RegExp("snipe");
```

```javascript
// /pattern/flags;
var re = /snipe/g;
```

-###-

## What will this match?

* `/s*n[iI1]p[eE3]/` will match the following:
	* snipe
	* sssnipe
	* ssssssssssssnIp3
	* sn1p3
	* nIpE

-###-

## The `*` Indicator

* This one indicator for matching repeated characters (or classes or patterns)
* `*`
	* Repeated 0 or more times

-###-

## The `+` Indicator

* `+`
	* Repeated 1 or more times

-###-

## The `?` Indicator

* `?`
	* Occurs 0 or 1 times

-###-

## The `{n}` Indicator

* `{n}`
	* Repeated exactly n times
* `{n, m}`
	* Repeated between n and m times

-###-

## The `[ ]`

* `[]` allows for the creation of character sets
* `[iI1]` matches:
	* `i`
	* `I`
	* `1`
* It does not match:
	* `I1`
	* `iii`
	* `1i`

-###-

## Complement Character Sets

* If a `^` appears as the first character in a character set, that set will match any character **not** listed in the character set.
* `[^iI1]` matches:
	* `q`
	* `7`
	* `T`

-###-

## Complement Character Sets

* `[^iI1]` does not match:
	* `i`
	* `I`
	* `1`

-###-

## More Character Sets

* `[abcdefghijklmnopqrstuvwxyz]`
* `[a-z]`
	* What would happen:  `"A".search(/[a-z]/)`
* `[A-Za-z0-9]`
* `[^A-Za-z0-9]`
* `[aeiouAEIOU]`
* `[0-9+-\/*]`
	* What does this match?

Note:
* Will find nothing (case sensitive
* Will match math expressions (\/ escapes the /, though not necessary in chrome, assumed since it is in a character class)
* Matches:
	* `3`
	* `+`
	* `-`
	* `*`
	* `/`
	* `.`
* Non-matches:
	* `\`

-###-

## Builtin Character Sets

* `\d`
	* Digits
	* [0-9]
* `\D`
	* Non Digits
	* `[^0-9]`

-###-

## Builtin Character Sets

* `\w`
	* Any alphanumeric character
	* `[A-Za-z0-9]`
* `\W`
	* Non-alphanumeric
	* `[^A-Za-z0-9]`

-###-

## Builtin Character Sets

* `\s`
	* "Space" characters (e.g., space, tab newline, etc.)
	* `[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029
\u202f\u205f\u3000\ufeff]`
* `\S`
	* Non-space characters
	* `[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029
\u202f\u205f\u3000\ufeff]`

-###-

## Anchors

* `^`
	* Matches the beginning of a string
	* Unless in multiline mode, then matches the beginning of a line
* `$`
	* Matches the end of a string
	* Unless in multiline mode, then matches the end of a line

-###-

## Anchors

* `\b`
	* Word boundary
* `\B`
	* Not a word boundary

-###-

## Greedy vs Lazy evaluation

* By default matches are greedy from left
* If multiple characters can be matched, as many are consumed as possible left to right, as long as overall match can still succeed
* Backtracking may be needed to obtain overall match
We can change the matching to be lazy by putting a ? after the repetition operator
* `/a*?/`
	* `"aaaaaaa".match(/a*?/)`
	* `"aaaaaaa".match(/a*/)`

-###-

## Subgroups `()`

* `()`
* "Saves" the results of a portion of the overall match
* Can recall previously matched values with `\n`
	* Where `n` is a number
* `"foofoo".match(/(.*)\1/)`
	* Finds a match!
* `"foobar".match(/(.*)\1/)`
	* ???
* `"barbaz".match(/(.*)\1/)`
	* ???

-###-

## Subgroup Utility

* Javascript will allow you to reference matched subgroups in the replace function with `$n`

```javascript
var re = /(\w+)\s(\w+)/;
var str = 'John Smith';
var newstr = str.replace(re, '$2, $1');
document.write(newstr);
```

-###-

## Flags

* `g`
	* Global search
* `i`
	* Case-insensitive search
* `m`
	* Multi-line search.
* `y`
	* Perform a "sticky" search that matches starting at the current position in the target string

-###-

## Other Functions

* `|`
	* Or
	* `/red|green/`
* `(?:x)`
	* matches, but does not save `x`
* `x(?=y)`
	* Matches `x` only if followed by `y`
* `x(?!y)`
	* Matches `x` only if it is not followed by `y`

-###-

## Exercises

* An Expression that:
	* Whether a string contains a valid floating point number
	* Whether a string represents a valid date
	* Whether a string represents a valid email address

-###-

## Advice

<!-- .slide: class="element-bkg" -->
<!-- .slide: data-background-image="https://media.tenor.com/images/049898e9e1d908f95877538e30307df5/tenor.gif" -->

* When developing a regular expression, consider two	different questions:
	* Does it MATCH all of the strings you want it to match?
	* Does it NOT MATCH all of the strings you do not want it to match?
* Mistakes are often made when only one of those questions is considered
